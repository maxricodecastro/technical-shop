# Shopping Assistant - Technical Architecture

## Overview
This document outlines the technical architecture for the AI Shopping Assistant. This is a **frontend-only application** built with Next.js 14+ (App Router), TypeScript, and Tailwind CSS.

**Design Principles:**
- Keep it simple - avoid over-engineering
- All data lives on the frontend
- No embeddings - LLM directly converts queries to filters
- Multiple focused prompt calls for different tasks
- Fast iteration over perfect architecture

## Tech Stack

### Core
- **Next.js 14+** (App Router) → Vercel deployment
- **React 18+** with TypeScript (strict mode)
- **Tailwind CSS** for styling

### UI
- **Catalyst UI Kit** - Premium Tailwind CSS components (from Tailwind Labs)
  - Built on Headless UI for accessibility
  - Uses `motion` (Framer Motion) for animations
  - Tailwind CSS v4.0 compatible
- **@headlessui/react** - Accessible primitives (Catalyst dependency)
- **motion** - Animations (Catalyst dependency)

### AI Services
- **Groq** - Fast LLM inference (Llama 3.3 70B) - Primary for filter generation
- **OpenAI GPT-4 Vision** - Image analysis only (describes uploaded images)

### Utilities
- **clsx** - className management (Catalyst dependency)
- **zod** - Runtime schema validation for LLM responses and facet validation
- **@radix-ui/react-slider** - Price range slider (not included in Catalyst)

## Core Concept: LLM as Filter Translator

Instead of using embeddings and semantic search, we use the LLM directly to translate user intent into filters.

### Chip Persistence (Phase 2)

Selected chips persist across queries while unselected chips refresh:

```
Query 1: "Jacob Elordi style"
→ Chips: [T-shirts] [Jeans] [Casual] [Denim]...
→ User selects: [Jeans ✓] [Casual ✓]

Query 2: "more baggy stuff"  
→ API receives: selectedChips = [Jeans, Casual]
→ LLM excludes these from suggestions
→ Response: [Oversized] [Relaxed] [Hoodies]... (no Jeans/Casual)
→ UI shows: [Jeans ✓] [Casual ✓] | [Oversized] [Relaxed] [Hoodies]...
            ← selected (persist)   ← new suggestions (replace old)
```

```
User: "I want a cozy sweater for winter, maybe in earth tones"
           │
           ▼
    ┌─────────────────┐
    │   Groq LLM      │
    │   (with catalog │
    │    facets)      │
    └────────┬────────┘
             │
             ▼ (LLM generates subcategory, material, style chips - NO colors)
{
  "message": "Looking for cozy winter sweaters! Here are some filters:",
  "chips": [
    { "type": "subcategory", "label": "Sweaters", "filterKey": "subcategory", "filterValue": "sweaters" },
    { "type": "material", "label": "Wool", "filterKey": "materials", "filterValue": "wool" },
    { "type": "style_tag", "label": "Cozy", "filterKey": "styleTags", "filterValue": "cozy" }
  ],
  "priceQuestion": "What's your budget for the sweater?"
}
             │
             ▼ (System post-processes chips)
Final chip order:
  1. Subcategories (from LLM)
  2. Materials: [LLM-suggested first] + [catalog supplements]
  3. Colors: fully derived from catalog for subcategories
  4. Style tags (from LLM)
```

### Data-Driven Colors

**Colors are NOT generated by the LLM.** Instead, colors are dynamically derived from the product catalog based on the suggested subcategories:

1. LLM suggests subcategories (e.g., sweaters, hoodies)
2. System queries catalog for all products in those subcategories
3. System extracts unique colors from those products
4. Color chips are added automatically

This ensures users only see colors that actually exist for the suggested product types.

### LLM-Driven Materials (No Supplementation)

**Materials are fully LLM-driven** - no catalog supplementation.

1. LLM generates material suggestions based on user intent
2. System validates LLM materials against catalog (invalid ones are removed)
3. Only LLM-suggested materials are returned (no catalog additions)

**Why no supplementation?**
- Materials are context-dependent: cashmere makes sense for "cozy" but NOT for "running"
- Supplementation was adding irrelevant materials that confused users
- LLM understands context better than a simple "get all materials" query

**Example:**
```
User: "running outfit"
LLM suggests: [cotton, polyester, fleece]  ← Context-appropriate
Catalog has: [cotton, polyester, fleece, cashmere, silk, leather, linen, denim, wool]
Result: [cotton, polyester, fleece]  ← Only relevant fabrics
```

### LLM-Driven Style Tags (No Supplementation)

**Style tags are fully LLM-driven** - no catalog supplementation.

1. LLM generates style tag suggestions based on user intent
2. System validates LLM style tags against catalog (invalid ones are removed)
3. Only LLM-suggested style tags are returned (no catalog additions)

**Why no supplementation?**
- Style tags are context-dependent: formal makes sense for "work" but NOT for "running"
- Supplementation was adding irrelevant styles that confused users
- LLM understands context better than a simple "get all styles" query

**Example:**
```
User: "running outfit"
LLM suggests: [casual, fitted, modern, relaxed]  ← Context-appropriate
Catalog has: [casual, classic, cozy, edgy, elegant, fitted, formal, minimalist, modern, oversized, relaxed, romantic, vintage]
Result: [casual, fitted, modern, relaxed]  ← Only relevant styles
```

## Project Structure

```
ramp-technical/
├── src/
│   ├── app/
│   │   ├── layout.tsx
│   │   ├── page.tsx                    # Main shopping page
│   │   ├── globals.css
│   │   └── api/
│   │       ├── chat/route.ts           # Groq - filter generation
│   │       ├── regenerate/route.ts     # Groq - alternative suggestions
│   │       ├── vision/route.ts         # GPT-4 Vision - image description
│   │       └── similar/route.ts        # Groq - similar product suggestions
│   │
│   ├── components/
│   │   ├── catalyst/                   # Catalyst UI Kit components (from Tailwind Labs)
│   │   │   ├── alert.tsx
│   │   │   ├── avatar.tsx
│   │   │   ├── badge.tsx               # BadgeButton for filter chips
│   │   │   ├── button.tsx
│   │   │   ├── checkbox.tsx
│   │   │   ├── dialog.tsx
│   │   │   ├── dropdown.tsx
│   │   │   ├── fieldset.tsx            # Field, Label, Description
│   │   │   ├── heading.tsx
│   │   │   ├── input.tsx
│   │   │   ├── link.tsx
│   │   │   ├── listbox.tsx
│   │   │   ├── select.tsx
│   │   │   ├── sidebar.tsx             # Sidebar, SidebarBody, SidebarFooter
│   │   │   ├── sidebar-layout.tsx
│   │   │   ├── switch.tsx              # For in-stock toggle
│   │   │   ├── text.tsx
│   │   │   └── textarea.tsx
│   │   │
│   │   ├── ui/                         # Custom UI components
│   │   │   ├── slider.tsx              # Price range (Radix-based)
│   │   │   ├── skeleton.tsx            # Loading shimmer
│   │   │   └── image-preview.tsx       # Uploaded image preview
│   │   │
│   │   ├── layout/
│   │   │   ├── Header.tsx
│   │   │   ├── Logo.tsx
│   │   │   ├── SearchBar.tsx           # Static placeholder for now
│   │   │   ├── CartIcon.tsx
│   │   │   └── ResizeHandle.tsx
│   │   │
│   │   ├── filters/
│   │   │   ├── FilterPanel.tsx         # Traditional filter sidebar
│   │   │   ├── CategoryFilter.tsx
│   │   │   ├── PriceFilter.tsx
│   │   │   ├── ColorFilter.tsx
│   │   │   ├── MaterialFilter.tsx
│   │   │   └── InStockFilter.tsx
│   │   │
│   │   ├── chat/
│   │   │   ├── ChatSidebar.tsx         # Main chat container
│   │   │   ├── ChatToggleButton.tsx    # "Try AI Assistant" button
│   │   │   ├── ConversationThread.tsx  # Scrollable message list
│   │   │   ├── Message.tsx             # Single message (user or assistant)
│   │   │   ├── FilterChip.tsx          # Clickable filter suggestion
│   │   │   ├── FilterChipGroup.tsx     # Group of chips in a message
│   │   │   ├── GlobalFilters.tsx       # Price/stock above input
│   │   │   ├── PromptInput.tsx         # Text input + image upload
│   │   │   ├── ImagePreview.tsx        # Uploaded image with X button
│   │   │   └── RegenerateButton.tsx    # "Show different suggestions"
│   │   │
│   │   ├── products/
│   │   │   ├── ProductGrid.tsx
│   │   │   ├── ProductCard.tsx
│   │   │   └── ProductSkeleton.tsx
│   │   │
│   │   └── shared/
│   │       └── ErrorBoundary.tsx
│   │
│   ├── lib/
│   │   ├── ai/
│   │   │   ├── prompts.ts              # All prompt templates
│   │   │   ├── chat.ts                 # Main chat logic
│   │   │   ├── vision.ts               # Image description logic
│   │   │   ├── parse.ts                # Parse LLM JSON responses
│   │   │   └── validate.ts             # Zod validation for LLM responses
│   │   │
│   │   ├── filters/
│   │   │   ├── engine.ts               # AND logic filter application
│   │   │   ├── ranking.ts              # Product ranking by match score
│   │   │   └── sync.ts                 # Sync chat filters ↔ traditional
│   │   │
│   │   ├── catalog/
│   │   │   ├── data.ts                 # Load and access product data
│   │   │   └── facets.ts               # Get available filter values
│   │   │
│   │   └── utils/
│   │       ├── cn.ts                   # clsx + tailwind-merge
│   │       ├── storage.ts              # localStorage helpers
│   │       └── format.ts               # Price formatting, etc.
│   │
│   ├── hooks/
│   │   ├── useAppState.ts              # Main app state (single source of truth)
│   │   ├── useResizable.ts             # Sidebar resize logic
│   │   └── useLocalStorage.ts          # Persist state
│   │
│   ├── types/
│   │   └── index.ts                    # All type definitions
│   │
│   ├── constants/
│   │   └── index.ts                    # Filter options, config
│   │
│   ├── data/
│   │   └── products.json               # Full catalog (~500 items)
│   │
│   └── styles/
│       ├── tokens.ts                   # Design tokens
│       └── animations.ts               # Framer Motion variants
│
├── public/
│   └── placeholder.svg                 # Fallback product image
│
├── .env.local
├── .env.example
├── tailwind.config.ts
├── next.config.js
└── package.json
```

## Type Definitions & Zod Schemas

```typescript
// types/index.ts
import { z } from 'zod'

// === Product ===
export interface Product {
  id: string
  title: string
  description: string
  image_url: string
  price: number
  in_stock: boolean
  category: 'apparel' | 'furniture'
  subcategory: string
  color: string
  material: string
  style_tags: string[]
  size?: string        // Apparel only
  brand?: string
}

// === Filters ===
export interface FilterState {
  category: string | null
  subcategory: string | null
  colors: string[]
  materials: string[]
  sizes: string[]
  minPrice: number | null
  maxPrice: number | null
  inStock: boolean | null
  styleTags: string[]
}

export const initialFilters: FilterState = {
  category: null,
  subcategory: null,
  colors: [],
  materials: [],
  sizes: [],
  minPrice: null,
  maxPrice: null,
  inStock: null,
  styleTags: [],
}

// === Filter Chips ===
export type ChipType = 
  | 'category' 
  | 'subcategory' 
  | 'color' 
  | 'material' 
  | 'style_tag' 
  | 'size'
  | 'price_range'

export interface FilterChip {
  id: string
  type: ChipType
  label: string           // Display text: "Blue", "Under $50"
  filterKey: keyof FilterState
  filterValue: unknown    // Value to apply
}

// === Chat ===
export interface Message {
  id: string
  role: 'user' | 'assistant'
  content: string
  imageUrl?: string                    // Base64 or object URL for user images
  suggestedChips?: FilterChip[]        // Assistant messages only
  priceQuestion?: string               // Price clarification prompt
  timestamp: number
}

// === Intent Mode & Replace Categories ===
export type IntentMode = 'replace' | 'refine' | 'explore'

export type ReplaceCategory =
  | 'all'              // Clear everything INCLUDING price
  | 'all_except_price' // Clear all chips but preserve price range
  | 'subcategory'
  | 'occasions'
  | 'materials'
  | 'colors'
  | 'style_tags'
  | 'sizes'
  | 'price'            // Clear only price (reset to full range)

// === LLM Response ===
export interface LLMResponse {
  message: string
  intentMode: IntentMode
  replaceCategories: ReplaceCategory[]
  chips: FilterChip[]
  priceQuestion?: string
  minPrice?: number | null  // Extracted minimum price from user query
  maxPrice?: number | null  // Extracted maximum price from user query
}

// === Chat Request ===
export interface ChatRequest {
  message: string
  conversationHistory?: Message[]
  currentFilters?: FilterState
  selectedChips?: FilterChip[]      // Chips user has selected (don't suggest duplicates)
  currentPriceRange?: {             // Current price slider state (manual or LLM-set)
    min: number
    max: number
    isDefault: boolean              // True if price range hasn't been modified
  }
}

// === Chat Response ===
export interface ChatResponse {
  raw: string
  parsed: LLMResponse | null
  suggestedChips: FilterChip[]
  intentMode: IntentMode
  replaceCategories: ReplaceCategory[]
  invalid: FilterChip[]
  errors: string[]
  matchingProducts?: Product[]
  minPrice?: number | null          // LLM-extracted minimum price for slider update
  maxPrice?: number | null          // LLM-extracted maximum price for slider update
  appliedFilters?: {                // State sync verification data
    suggestedChipCount: number
    effectiveMinPrice: number | null
    effectiveMaxPrice: number | null
    totalProductsBeforeFilter: number
    totalProductsAfterFilter: number
  }
}

// === UI State ===
export interface UIState {
  sidebarOpen: boolean
  sidebarWidth: number                 // Percentage (30-50)
}

// === Cart ===
export interface CartItem {
  productId: string
  quantity: number
}

// === App State ===
export interface AppState {
  filters: FilterState
  messages: Message[]
  chatLoading: boolean
  ui: UIState
  cart: CartItem[]
}

// === Catalog Facets (for prompts) ===
export interface CatalogFacets {
  categories: string[]
  subcategoriesByCategory: Record<string, string[]>
  colors: string[]
  materials: string[]
  styleTags: string[]
  sizes: string[]
  priceRange: { min: number, max: number }
}

// ============================================
// ZOD SCHEMAS - Runtime Validation
// ============================================

// === Filter Chip Schema ===
export const FilterChipSchema = z.object({
  id: z.string().optional(), // Generated client-side if missing
  type: z.enum(['category', 'subcategory', 'color', 'material', 'style_tag', 'size', 'price_range']),
  label: z.string().min(1),
  filterKey: z.enum(['category', 'subcategory', 'colors', 'materials', 'sizes', 'minPrice', 'maxPrice', 'inStock', 'styleTags']),
  filterValue: z.unknown(),
})

// === LLM Chat Response Schema ===
export const LLMChatResponseSchema = z.object({
  message: z.string().min(1, 'Response message cannot be empty'),
  chips: z.array(FilterChipSchema).max(10, 'Too many chips suggested'),
  priceQuestion: z.string().nullish(), // Can be string, null, or undefined
  minPrice: z.number().nullish(),     // Extracted minimum price from user query
  maxPrice: z.number().nullish(),     // Extracted maximum price from user query
})

// === LLM Regenerate Response Schema ===
export const LLMRegenerateResponseSchema = z.object({
  message: z.string().min(1),
  chips: z.array(FilterChipSchema).max(10),
})

// === LLM Similar Products Response Schema ===
export const LLMSimilarResponseSchema = z.object({
  message: z.string().min(1),
  alternatives: z.array(z.object({
    description: z.string(),
    chips: z.array(FilterChipSchema),
  })).max(5),
})

// === Facet Validation Schema Factory ===
// Creates a schema that validates chips against actual catalog facets
export function createFacetValidationSchema(facets: CatalogFacets) {
  const validColors = new Set(facets.colors.map(c => c.toLowerCase()))
  const validMaterials = new Set(facets.materials.map(m => m.toLowerCase()))
  const validStyleTags = new Set(facets.styleTags.map(t => t.toLowerCase()))
  const validSizes = new Set(facets.sizes.map(s => s.toLowerCase()))
  const validCategories = new Set(facets.categories.map(c => c.toLowerCase()))
  const validSubcategories = new Set(
    Object.values(facets.subcategoriesByCategory).flat().map(s => s.toLowerCase())
  )

  return z.object({
    message: z.string(),
    chips: z.array(FilterChipSchema).superRefine((chips, ctx) => {
      chips.forEach((chip, index) => {
        const value = String(chip.filterValue).toLowerCase()
        
        switch (chip.filterKey) {
          case 'colors':
            if (!validColors.has(value)) {
              ctx.addIssue({
                code: z.ZodIssueCode.custom,
                message: `Invalid color: "${chip.filterValue}". Available: ${facets.colors.join(', ')}`,
                path: [index, 'filterValue'],
              })
            }
            break
          case 'materials':
            if (!validMaterials.has(value)) {
              ctx.addIssue({
                code: z.ZodIssueCode.custom,
                message: `Invalid material: "${chip.filterValue}". Available: ${facets.materials.join(', ')}`,
                path: [index, 'filterValue'],
              })
            }
            break
          case 'styleTags':
            if (!validStyleTags.has(value)) {
              ctx.addIssue({
                code: z.ZodIssueCode.custom,
                message: `Invalid style tag: "${chip.filterValue}". Available: ${facets.styleTags.join(', ')}`,
                path: [index, 'filterValue'],
              })
            }
            break
          case 'sizes':
            if (!validSizes.has(value)) {
              ctx.addIssue({
                code: z.ZodIssueCode.custom,
                message: `Invalid size: "${chip.filterValue}". Available: ${facets.sizes.join(', ')}`,
                path: [index, 'filterValue'],
              })
            }
            break
          case 'category':
            if (!validCategories.has(value)) {
              ctx.addIssue({
                code: z.ZodIssueCode.custom,
                message: `Invalid category: "${chip.filterValue}". Available: ${facets.categories.join(', ')}`,
                path: [index, 'filterValue'],
              })
            }
            break
          case 'subcategory':
            if (!validSubcategories.has(value)) {
              ctx.addIssue({
                code: z.ZodIssueCode.custom,
                message: `Invalid subcategory: "${chip.filterValue}"`,
                path: [index, 'filterValue'],
              })
            }
            break
        }
      })
    }),
    priceQuestion: z.string().optional(),
  })
}

// === Type exports from schemas ===
export type ValidatedFilterChip = z.infer<typeof FilterChipSchema>
export type ValidatedLLMResponse = z.infer<typeof LLMChatResponseSchema>
```

## State Management

Using a **single custom hook** with `useReducer` for simplicity.

### useAppState Hook

```typescript
// hooks/useAppState.ts

type Action =
  | { type: 'SET_FILTER'; key: keyof FilterState; value: unknown }
  | { type: 'CLEAR_FILTERS' }
  | { type: 'SYNC_FILTERS'; filters: Partial<FilterState> }
  | { type: 'ADD_MESSAGE'; message: Message }
  | { type: 'SET_CHAT_LOADING'; loading: boolean }
  | { type: 'CLEAR_CHAT' }
  | { type: 'TOGGLE_SIDEBAR' }
  | { type: 'SET_SIDEBAR_WIDTH'; width: number }
  | { type: 'ADD_TO_CART'; productId: string }
  | { type: 'REMOVE_FROM_CART'; productId: string }

function reducer(state: AppState, action: Action): AppState {
  switch (action.type) {
    case 'SET_FILTER':
      return { ...state, filters: { ...state.filters, [action.key]: action.value } }
    case 'CLEAR_FILTERS':
      return { ...state, filters: initialFilters }
    case 'TOGGLE_SIDEBAR':
      return { ...state, ui: { ...state.ui, sidebarOpen: !state.ui.sidebarOpen } }
    // ... other cases
  }
}

export function useAppState() {
  const [state, dispatch] = useReducer(reducer, initialState)
  
  // Persist UI state to localStorage
  useEffect(() => {
    localStorage.setItem('ui', JSON.stringify(state.ui))
  }, [state.ui])
  
  return { state, dispatch }
}
```

## Component Architecture

### Component Hierarchy

```
ShopPage (page.tsx)
│
├─ Header
│  ├─ Logo
│  ├─ SearchBar (static placeholder - future feature)
│  └─ CartIcon (shows count)
│
├─ Main Content (flex)
│  │
│  ├─ Left Side
│  │  │
│  │  ├─ [If !sidebarOpen] FilterPanel
│  │  │  ├─ CategoryFilter
│  │  │  ├─ PriceFilter (slider)
│  │  │  ├─ ColorFilter (checkboxes)
│  │  │  ├─ MaterialFilter (checkboxes)
│  │  │  └─ InStockFilter (switch)
│  │  │
│  │  ├─ [If !sidebarOpen] ChatToggleButton (BELOW FilterPanel)
│  │  │  └─ "✨ Try AI Assistant"
│  │  │
│  │  └─ [If sidebarOpen] ChatSidebar
│  │     ├─ Header: "AI Assistant" + Close button
│  │     ├─ ConversationThread (scrollable)
│  │     │  └─ Message[] 
│  │     │     ├─ [user] Text + optional ImagePreview
│  │     │     └─ [assistant] 
│  │     │        ├─ Text response
│  │     │        ├─ FilterChipGroup
│  │     │        ├─ RegenerateButton
│  │     │        └─ PriceQuestion (if present)
│  │     ├─ GlobalFilters (fixed)
│  │     │  ├─ PriceSlider (compact, controlled by minPrice/maxPrice from LLM)
│  │     │  └─ InStockFilter (compact)
│  │     └─ PromptInput (fixed bottom)
│  │        ├─ ImagePreview (if image attached)
│  │        └─ Input + Send button
│  │
│  ├─ [If sidebarOpen] ResizeHandle
│  │
│  └─ ProductGrid
│     ├─ ProductCard[] (with Add to Cart)
│     ├─ ProductSkeleton[] (loading shimmer)
│     └─ IntersectionObserver trigger (infinite scroll)
```

### Key Component Behaviors

#### ChatToggleButton
- Positioned **below** the FilterPanel (not inside it)
- Clicking opens the ChatSidebar and hides FilterPanel
- Label: "✨ Try AI Assistant" or similar

#### SearchBar (Static)
- Visible in header but non-functional for MVP
- Placeholder text: "Search products..."
- **UNCLEAR:** Should clicking it do anything? Or completely static?

#### PriceSlider
- Located in GlobalFilters section (always visible above prompt input)
- Controlled by `minPrice` and `maxPrice` values extracted from LLM responses
- Range inferred from user queries: "budget is $200" → $0 to $200, "minimum $200" → $200 to max
- Updates automatically when LLM extracts price values from user messages
- User can also manually adjust the slider, which sends updated prices in subsequent requests

## AI Integration: Multi-Prompt Architecture

We use multiple focused prompts for different tasks:

### Prompt 1: Main Chat → Filter Generation
**Route:** `/api/chat`
**Model:** Groq (Llama 3.3 70B)
**Purpose:** Convert user messages into filter suggestions (subcategory, material, style - colors are data-driven)

### Prompt 2: Regenerate Suggestions  
**Route:** `/api/regenerate`
**Model:** Groq (Llama 3.3 70B)
**Purpose:** Generate alternative filter suggestions for same query

### Prompt 3: Image Analysis
**Route:** `/api/vision`
**Model:** OpenAI GPT-4 Vision
**Purpose:** Describe uploaded images to understand what user is looking for

### Prompt 4: Similar Products (Zero Results)
**Route:** `/api/similar`
**Model:** Groq (Llama 3.3 70B)
**Purpose:** When filters return zero results, suggest related products

---

## API Routes

### `/api/chat/route.ts` - Main Filter Generation

```typescript
import Groq from 'groq-sdk'

const groq = new Groq({ apiKey: process.env.GROQ_API_KEY })

export async function POST(request: Request) {
  const { userMessage, conversationHistory, currentFilters, catalogFacets } = await request.json()
  
  const systemPrompt = buildFilterGenerationPrompt(catalogFacets, currentFilters)
  
  const completion = await groq.chat.completions.create({
    model: 'llama-3.3-70b-versatile',
    messages: [
      { role: 'system', content: systemPrompt },
      ...conversationHistory,
      { role: 'user', content: userMessage },
    ],
    temperature: 0.7,
    max_tokens: 1024,
  })
  
  const parsed = parseFilterResponse(completion.choices[0].message.content)
  return Response.json(parsed)
}
```

### `/api/regenerate/route.ts` - Alternative Suggestions

```typescript
export async function POST(request: Request) {
  const { originalQuery, previousChips, catalogFacets, currentFilters } = await request.json()
  
  const systemPrompt = buildRegeneratePrompt(catalogFacets, currentFilters, previousChips)
  
  const completion = await groq.chat.completions.create({
    model: 'llama-3.3-70b-versatile',
    messages: [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: `Original request: "${originalQuery}". Give me DIFFERENT filter suggestions.` },
    ],
    temperature: 0.9,  // Higher temp for more variety
    max_tokens: 1024,
  })
  
  const parsed = parseFilterResponse(completion.choices[0].message.content)
  return Response.json(parsed)
}
```

### `/api/vision/route.ts` - Image Description

```typescript
import OpenAI from 'openai'

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY })

export async function POST(request: Request) {
  const { imageBase64 } = await request.json()
  
  const response = await openai.chat.completions.create({
    model: 'gpt-4o',
    messages: [
      {
        role: 'user',
        content: [
          {
            type: 'text',
            text: `Describe this image for a shopping assistant. Focus on:
- What type of item is this? (clothing, furniture, etc.)
- Colors present
- Style/aesthetic (modern, vintage, casual, formal, etc.)
- Material if visible
- Any other relevant shopping attributes

Be concise. Format as a shopping query.`,
          },
          {
            type: 'image_url',
            image_url: { url: `data:image/jpeg;base64,${imageBase64}` },
          },
        ],
      },
    ],
    max_tokens: 300,
  })
  
  return Response.json({
    description: response.choices[0].message.content,
  })
}
```

### `/api/similar/route.ts` - Similar Products for Zero Results

```typescript
export async function POST(request: Request) {
  const { appliedFilters, catalogFacets, allProducts } = await request.json()
  
  const systemPrompt = buildSimilarProductsPrompt(catalogFacets)
  
  // Send the filters that produced zero results
  const userMessage = `
The user applied these filters but got zero results:
${JSON.stringify(appliedFilters, null, 2)}

Suggest 3-5 alternative filter combinations that would show similar products.
Relax the most specific filters first.
`
  
  const completion = await groq.chat.completions.create({
    model: 'llama-3.3-70b-versatile',
    messages: [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userMessage },
    ],
    temperature: 0.7,
    max_tokens: 1024,
  })
  
  const parsed = parseSimilarResponse(completion.choices[0].message.content)
  return Response.json(parsed)
}
```

---

## Prompt Templates

### Filter Generation Prompt

```typescript
// lib/ai/prompts.ts

export function buildFilterGenerationPrompt(
  facets: CatalogFacets,
  currentFilters: FilterState
): string {
  return `You are a shopping assistant for an online store selling apparel and furniture.

Your job is to understand what the user wants and suggest filter chips they can click to find products.

AVAILABLE FILTERS (ONLY use these exact values):
- Categories: ${facets.categories.join(', ')}
- Subcategories by category: ${JSON.stringify(facets.subcategoriesByCategory)}
- Colors: ${facets.colors.join(', ')}
- Materials: ${facets.materials.join(', ')}
- Style tags: ${facets.styleTags.join(', ')}
- Sizes (apparel only): ${facets.sizes.join(', ')}
- Price range: $${facets.priceRange.min} - $${facets.priceRange.max}

CURRENTLY APPLIED FILTERS:
${JSON.stringify(currentFilters, null, 2)}

RULES:
1. ONLY suggest filters from the exact values listed above. Never invent new ones.
2. Start with category/subcategory if not already set.
3. Then suggest 2-4 attribute filters (color, material, style).
4. Keep your message brief and helpful.
5. If user hasn't mentioned price/budget, include a price question.
6. If user asks for something not in the catalog, acknowledge it and suggest the closest alternatives.

RESPONSE FORMAT (JSON only):
{
  "message": "Brief helpful response to the user",
  "chips": [
    { 
      "type": "subcategory",
      "label": "Sweaters", 
      "filterKey": "subcategory", 
      "filterValue": "sweaters" 
    },
    { 
      "type": "color",
      "label": "Blue", 
      "filterKey": "colors", 
      "filterValue": "blue" 
    }
  ],
  "priceQuestion": "What's your budget?" // Include if user hasn't specified price, omit otherwise
}

Respond with valid JSON only. No markdown, no explanation outside the JSON.`
}
```

### Regenerate Prompt

```typescript
export function buildRegeneratePrompt(
  facets: CatalogFacets,
  currentFilters: FilterState,
  previousChips: FilterChip[]
): string {
  return `You are a shopping assistant. The user wants DIFFERENT suggestions than before.

AVAILABLE FILTERS: [same as above]

PREVIOUSLY SUGGESTED (DO NOT repeat these):
${previousChips.map(c => `- ${c.label}`).join('\n')}

Generate fresh alternative suggestions. Be creative but stay within available filters.
If previous suggestions were specific colors, try different colors.
If previous suggestions were one subcategory, try related subcategories.

RESPONSE FORMAT: [same JSON format as filter generation]`
}
```

### Similar Products Prompt (Zero Results)

```typescript
export function buildSimilarProductsPrompt(facets: CatalogFacets): string {
  return `You are a shopping assistant. The user's filters produced zero results.

Help them find similar products by suggesting relaxed filter combinations.

AVAILABLE FILTERS: [list all facets]

Your job:
1. Analyze which filters are too restrictive
2. Suggest 3-5 alternative filter combinations
3. Explain briefly why each might work

RESPONSE FORMAT (JSON):
{
  "message": "Couldn't find exact matches, but here are some alternatives:",
  "alternatives": [
    {
      "description": "Similar style in different color",
      "chips": [...]
    },
    {
      "description": "Same color, different material", 
      "chips": [...]
    }
  ]
}`
}
```

---

## Data Flow

### Flow 1: Text Message

```
User types: "I want a cozy sweater"
           │
           ▼
┌─ ChatSidebar ─────────────────────────┐
│  1. Show user message in thread       │
│  2. Set chatLoading = true            │
│  3. Call /api/chat                    │
└───────────────────────────────────────┘
           │
           ▼
┌─ /api/chat ───────────────────────────┐
│  1. Build prompt with catalog facets  │
│  2. Include conversation history      │
│  3. Call Groq LLM                     │
│  4. Parse JSON response               │
│  5. Validate with Zod schemas         │
│  6. Filter out invalid facet values   │
└───────────────────────────────────────┘
           │
           ▼
┌─ ChatSidebar ─────────────────────────┐
│  1. Add assistant message to state    │
│  2. Display validated chips only      │
│  3. Set chatLoading = false           │
└───────────────────────────────────────┘
           │
           ▼
User clicks chip "Sweaters"
           │
           ▼
dispatch({ type: 'SET_FILTER', key: 'subcategory', value: 'sweaters' })
           │
           ▼
filterAndRankProducts() → Filters AND ranks by match score
           │
           ▼
Grid shows sweaters (best matches first)
```

### Flow 2: Image Upload

```
User uploads image of a blue velvet sofa
           │
           ▼
┌─ PromptInput ─────────────────────────┐
│  1. Convert image to base64           │
│  2. Show preview with X button        │
└───────────────────────────────────────┘
           │
User clicks Send (or types "find similar")
           │
           ▼
┌─ ChatSidebar ─────────────────────────┐
│  1. Call /api/vision with image       │
└───────────────────────────────────────┘
           │
           ▼
┌─ /api/vision (GPT-4 Vision) ──────────┐
│  Returns: "A modern blue velvet sofa  │
│  with clean lines, contemporary style"│
└───────────────────────────────────────┘
           │
           ▼
┌─ ChatSidebar ─────────────────────────┐
│  1. Take description from vision API  │
│  2. Call /api/chat with description   │
│     as the user message               │
└───────────────────────────────────────┘
           │
           ▼
┌─ /api/chat ───────────────────────────┐
│  Input: "A modern blue velvet sofa    │
│  with clean lines, contemporary style"│
│                                       │
│  Output: chips for sofa, blue, velvet,│
│  modern style tag                     │
└───────────────────────────────────────┘
           │
           ▼
Display chips → User clicks → Grid filters
```

### Flow 3: Regenerate

```
User clicks "Show different suggestions"
           │
           ▼
┌─ RegenerateButton ────────────────────┐
│  1. Get original query from message   │
│  2. Get previous chips                │
│  3. Call /api/regenerate              │
└───────────────────────────────────────┘
           │
           ▼
┌─ /api/regenerate ─────────────────────┐
│  1. Build prompt excluding prev chips │
│  2. Higher temperature for variety    │
│  3. Return new set of chips           │
└───────────────────────────────────────┘
           │
           ▼
Update assistant message with new chips
(or append new message with alternatives)
```

### Flow 4: Zero Results

```
User applies filters → 0 products match
           │
           ▼
┌─ ProductGrid ─────────────────────────┐
│  Detects: filteredProducts.length = 0 │
│  Triggers: /api/similar               │
└───────────────────────────────────────┘
           │
           ▼
┌─ /api/similar ────────────────────────┐
│  1. Analyze which filters are strict  │
│  2. Suggest relaxed alternatives      │
│  3. Return alternative chip sets      │
└───────────────────────────────────────┘
           │
           ▼
┌─ ChatSidebar / ProductGrid ───────────┐
│  Show: "No exact matches found"       │
│  Show: Alternative suggestions        │
│  "Try these instead:"                 │
│  [Chip set 1] [Chip set 2] [Chip set 3]│
└───────────────────────────────────────┘
```

### Flow 5: Close Sidebar → Sync Filters

```
User clicks X to close ChatSidebar
           │
           ▼
┌─ ChatSidebar ─────────────────────────┐
│  1. Get currently applied filters     │
│  2. dispatch({ type: 'TOGGLE_SIDEBAR' })│
└───────────────────────────────────────┘
           │
           ▼
FilterPanel appears with same filters applied
(filters stay in state, just UI changes)
```

---

## Filter Engine

### AND Logic Implementation (for applied filters)

```typescript
// lib/filters/engine.ts

export function applyFilters(products: Product[], filters: FilterState): Product[] {
  return products.filter(product => {
    // Category
    if (filters.category && product.category !== filters.category) return false
    
    // Subcategory
    if (filters.subcategory && product.subcategory !== filters.subcategory) return false
    
    // Colors (OR within array, AND with other filters)
    if (filters.colors.length > 0 && !filters.colors.includes(product.color)) return false
    
    // Materials
    if (filters.materials.length > 0 && !filters.materials.includes(product.material)) return false
    
    // Sizes
    if (filters.sizes.length > 0 && product.size && !filters.sizes.includes(product.size)) return false
    
    // Price range
    if (filters.minPrice !== null && product.price < filters.minPrice) return false
    if (filters.maxPrice !== null && product.price > filters.maxPrice) return false
    
    // In stock
    if (filters.inStock === true && !product.in_stock) return false
    
    // Style tags (OR within array)
    if (filters.styleTags.length > 0) {
      const hasMatchingTag = filters.styleTags.some(tag => product.style_tags.includes(tag))
      if (!hasMatchingTag) return false
    }
    
    return true
  })
}
```

### OR Logic for Preview (suggested chips)

When showing a preview of products for suggested chips, we use a two-phase approach:

**Phase 1: Occasion Pre-Filter (Hard Gate)**
If occasion chips are present, products MUST match at least one occasion. This ensures activity-based queries like "running" only show athletic products.

```typescript
// In /api/chat route
const occasionChips = suggestedChips.filter(c => c.type === 'occasion')
let productsToSearch = products

if (occasionChips.length > 0) {
  const occasions = occasionChips.map(c => c.filterValue as string)
  productsToSearch = products.filter(p => 
    p.occasion.some(occ => occasions.includes(occ))
  )
}
```

**Phase 2: OR Logic for Other Chips**
Within the occasion-filtered set, OR logic applies - products matching ANY remaining chip are shown, ranked by match count:

```typescript
export function findProductsMatchingAnyChip(products: Product[], chips: FilterChip[]): Product[] {
  // Score each product by how many chips it matches
  const scored = products.map(product => ({
    product,
    score: chips.filter(chip => doesProductMatchChip(product, chip)).length
  }))
  
  // Return products matching at least one chip, sorted by score
  return scored
    .filter(s => s.score > 0)
    .sort((a, b) => b.score - a.score)
    .map(s => s.product)
}
```

### Data-Driven Facet Functions

Colors are fully derived from the catalog. Materials are supplemented (LLM suggestions first, then catalog additions).

```typescript
// Get all colors available for given subcategories (fully data-driven)
export function getColorsForSubcategories(products: Product[], subcategories: string[]): string[] {
  const colors = new Set<string>()
  for (const product of products) {
    if (subcategories.includes(product.subcategory)) {
      colors.add(product.color)
    }
  }
  return Array.from(colors).sort()
}

// Get all materials available for given subcategories (used to supplement LLM suggestions)
export function getMaterialsForSubcategories(products: Product[], subcategories: string[]): string[] {
  const materials = new Set<string>()
  for (const product of products) {
    if (subcategories.includes(product.subcategory)) {
      materials.add(product.material)
    }
  }
  return Array.from(materials).sort()
}
```

### Chip Processing Flow

```typescript
// In /api/chat/route.ts - processChipsWithDerivedFacets()

function processChipsWithDerivedFacets(llmChips, products) {
  // 1. Separate chips by type
  const subcategoryChips = llmChips.filter(c => c.type === 'subcategory')
  const materialChips = llmChips.filter(c => c.type === 'material')  // LLM materials (context-aware)
  const styleChips = llmChips.filter(c => c.type === 'style_tag')    // LLM style tags (context-aware)
  // Remove any LLM color chips (colors are data-driven)
  
  // 2. Get subcategory values
  const subcategories = subcategoryChips.map(c => c.filterValue)
  
  // 3. Derive colors from catalog (fully data-driven)
  const availableColors = getColorsForSubcategories(products, subcategories)
  const colorChips = availableColors.map(color => createColorChip(color))
  
  // 4. Materials: LLM-only (no supplementation)
  // LLM is context-aware and only suggests relevant materials
  // e.g., "running" → cotton, polyester (NOT cashmere, silk)
  
  // 5. Style tags: LLM-only (no supplementation)
  // LLM is context-aware and only suggests relevant styles
  // e.g., "running" → casual, fitted (NOT formal, elegant)
  
  // 6. Return in order: subcategories, materials (LLM-only), colors (data-driven), styles (LLM-only)
  return [
    ...subcategoryChips,  // LLM-driven
    ...materialChips,     // LLM-driven (context-aware, no supplements)
    ...colorChips,        // Data-driven (from catalog)
    ...styleChips,        // LLM-driven (context-aware, no supplements)
  ]
}
```

---

## Product Ranking

Products are ranked by **matching tag count** - products with the highest number of matching filter criteria appear first. This creates a "best match" ordering that prioritizes products closest to what the user is looking for.

### Ranking Implementation

```typescript
// lib/filters/ranking.ts

interface MatchScore {
  product: Product
  score: number
  matchedCriteria: string[]
}

/**
 * Calculates how many filter criteria a product matches.
 * Higher scores = better match = appears first in results.
 */
export function calculateMatchScore(product: Product, filters: FilterState): MatchScore {
  let score = 0
  const matchedCriteria: string[] = []

  // Category match (+1)
  if (filters.category && product.category === filters.category) {
    score += 1
    matchedCriteria.push(`category:${product.category}`)
  }

  // Subcategory match (+2, weighted higher as more specific)
  if (filters.subcategory && product.subcategory === filters.subcategory) {
    score += 2
    matchedCriteria.push(`subcategory:${product.subcategory}`)
  }

  // Color match (+1 per matching color)
  if (filters.colors.length > 0 && filters.colors.includes(product.color)) {
    score += 1
    matchedCriteria.push(`color:${product.color}`)
  }

  // Material match (+1 per matching material)
  if (filters.materials.length > 0 && filters.materials.includes(product.material)) {
    score += 1
    matchedCriteria.push(`material:${product.material}`)
  }

  // Size match (+1)
  if (filters.sizes.length > 0 && product.size && filters.sizes.includes(product.size)) {
    score += 1
    matchedCriteria.push(`size:${product.size}`)
  }

  // Style tags match (+1 per matching tag)
  if (filters.styleTags.length > 0) {
    const matchingTags = filters.styleTags.filter(tag => product.style_tags.includes(tag))
    score += matchingTags.length
    matchingTags.forEach(tag => matchedCriteria.push(`style:${tag}`))
  }

  // Price proximity bonus (+1 if within mid-range of filter)
  if (filters.minPrice !== null && filters.maxPrice !== null) {
    const midPrice = (filters.minPrice + filters.maxPrice) / 2
    const range = filters.maxPrice - filters.minPrice
    const distanceFromMid = Math.abs(product.price - midPrice)
    // Bonus for being close to the middle of the price range
    if (distanceFromMid < range * 0.25) {
      score += 1
      matchedCriteria.push('price:mid-range')
    }
  }

  // In-stock bonus (+1 if filtering for in-stock and product is in stock)
  if (filters.inStock === true && product.in_stock) {
    score += 1
    matchedCriteria.push('in_stock')
  }

  return { product, score, matchedCriteria }
}

/**
 * Ranks products by match score (highest first).
 * Products with same score maintain stable ordering.
 */
export function rankProducts(products: Product[], filters: FilterState): Product[] {
  // If no filters applied, return original order
  const hasActiveFilters = 
    filters.category !== null ||
    filters.subcategory !== null ||
    filters.colors.length > 0 ||
    filters.materials.length > 0 ||
    filters.sizes.length > 0 ||
    filters.styleTags.length > 0 ||
    filters.minPrice !== null ||
    filters.maxPrice !== null ||
    filters.inStock !== null

  if (!hasActiveFilters) {
    return products
  }

  // Calculate scores for all products
  const scored = products.map(product => calculateMatchScore(product, filters))

  // Sort by score descending (highest match count first)
  scored.sort((a, b) => b.score - a.score)

  return scored.map(s => s.product)
}

/**
 * Combined filter + rank: filters products AND ranks by match score
 */
export function filterAndRankProducts(products: Product[], filters: FilterState): Product[] {
  const filtered = applyFilters(products, filters)
  return rankProducts(filtered, filters)
}
```

### Usage in ProductGrid

```typescript
// In page.tsx or ProductGrid component

// Instead of just filtering:
// const filteredProducts = applyFilters(allProducts, state.filters)

// Now filter AND rank:
const filteredProducts = filterAndRankProducts(allProducts, state.filters)
const visibleProducts = filteredProducts.slice(0, displayCount)
```

---

## LLM Response Validation

All LLM responses are validated using Zod schemas to ensure:
1. Response structure is correct
2. Suggested filters use valid facet values from the catalog
3. Invalid/hallucinated filter values are caught and handled

### Validation Implementation

```typescript
// lib/ai/validate.ts
import { z } from 'zod'
import { 
  LLMChatResponseSchema, 
  createFacetValidationSchema,
  type CatalogFacets,
  type FilterChip 
} from '@/types'

interface ValidationResult {
  success: boolean
  data?: {
    message: string
    chips: FilterChip[]
    priceQuestion?: string
  }
  errors?: string[]
  invalidChips?: FilterChip[]
}

/**
 * Validates and sanitizes LLM response.
 * Returns valid chips only, filtering out any that reference invalid facets.
 */
export function validateLLMResponse(
  rawResponse: unknown,
  facets: CatalogFacets
): ValidationResult {
  // Step 1: Validate basic structure
  const structureResult = LLMChatResponseSchema.safeParse(rawResponse)
  
  if (!structureResult.success) {
    return {
      success: false,
      errors: structureResult.error.errors.map(e => `${e.path.join('.')}: ${e.message}`),
    }
  }

  // Step 2: Validate against actual catalog facets
  const facetSchema = createFacetValidationSchema(facets)
  const facetResult = facetSchema.safeParse(structureResult.data)

  if (!facetResult.success) {
    // Collect invalid chips but don't fail entirely
    const invalidChipIndices = new Set<number>()
    const errors: string[] = []

    facetResult.error.errors.forEach(err => {
      if (typeof err.path[0] === 'number') {
        invalidChipIndices.add(err.path[0])
      }
      errors.push(err.message)
    })

    // Filter out invalid chips, keep valid ones
    const validChips = structureResult.data.chips.filter(
      (_, index) => !invalidChipIndices.has(index)
    )
    const invalidChips = structureResult.data.chips.filter(
      (_, index) => invalidChipIndices.has(index)
    )

    // Add IDs to valid chips
    const chipsWithIds = validChips.map((chip, index) => ({
      ...chip,
      id: chip.id || `chip-${Date.now()}-${index}`,
    }))

    return {
      success: true, // Partial success - we have some valid chips
      data: {
        message: structureResult.data.message,
        chips: chipsWithIds,
        priceQuestion: structureResult.data.priceQuestion,
      },
      errors,
      invalidChips,
    }
  }

  // All chips valid - add IDs
  const chipsWithIds = structureResult.data.chips.map((chip, index) => ({
    ...chip,
    id: chip.id || `chip-${Date.now()}-${index}`,
  }))

  return {
    success: true,
    data: {
      message: structureResult.data.message,
      chips: chipsWithIds,
      priceQuestion: structureResult.data.priceQuestion,
    },
  }
}

/**
 * Parse and validate raw JSON string from LLM
 */
export function parseAndValidateLLMResponse(
  rawText: string,
  facets: CatalogFacets
): ValidationResult {
  // Try to extract JSON from response (LLM might include markdown)
  let jsonStr = rawText.trim()
  
  // Remove markdown code fences if present
  const jsonMatch = rawText.match(/```(?:json)?\s*([\s\S]*?)```/)
  if (jsonMatch) {
    jsonStr = jsonMatch[1].trim()
  }

  try {
    const parsed = JSON.parse(jsonStr)
    return validateLLMResponse(parsed, facets)
  } catch (e) {
    return {
      success: false,
      errors: [`Failed to parse JSON: ${e instanceof Error ? e.message : 'Unknown error'}`],
    }
  }
}
```

### Usage in API Routes

```typescript
// In /api/chat/route.ts

import { parseAndValidateLLMResponse } from '@/lib/ai/validate'
import { getCatalogFacets } from '@/lib/catalog/facets'

export async function POST(request: Request) {
  const { userMessage, conversationHistory, currentFilters } = await request.json()
  
  // Get catalog facets for validation
  const catalogFacets = getCatalogFacets()
  
  const systemPrompt = buildFilterGenerationPrompt(catalogFacets, currentFilters)
  
  const completion = await groq.chat.completions.create({
    model: 'llama-3.3-70b-versatile',
    messages: [
      { role: 'system', content: systemPrompt },
      ...conversationHistory,
      { role: 'user', content: userMessage },
    ],
    temperature: 0.7,
    max_tokens: 1024,
  })
  
  const rawContent = completion.choices[0].message.content || ''
  
  // Validate response against catalog facets
  const validated = parseAndValidateLLMResponse(rawContent, catalogFacets)
  
  if (!validated.success || !validated.data) {
    // Fallback response if validation completely fails
    return Response.json({
      message: "I had trouble understanding that. Could you try rephrasing?",
      chips: [],
      errors: validated.errors,
    })
  }
  
  // Log any invalid chips for debugging (optional)
  if (validated.invalidChips?.length) {
    console.warn('LLM suggested invalid chips:', validated.invalidChips)
  }
  
  return Response.json(validated.data)
}
```

---

## Infinite Scroll

Simple implementation - just track display count and slice:

```typescript
// In page.tsx or ProductGrid

const [displayCount, setDisplayCount] = useState(20)
const filteredProducts = applyFilters(allProducts, state.filters)
const visibleProducts = filteredProducts.slice(0, displayCount)
const hasMore = displayCount < filteredProducts.length

// Intersection Observer to load more
const loadMoreRef = useRef<HTMLDivElement>(null)

useEffect(() => {
  const observer = new IntersectionObserver(
    ([entry]) => {
      if (entry.isIntersecting && hasMore) {
        setDisplayCount(prev => prev + 20)
      }
    },
    { threshold: 0.1 }
  )
  
  if (loadMoreRef.current) {
    observer.observe(loadMoreRef.current)
  }
  
  return () => observer.disconnect()
}, [hasMore])

// Reset display count when filters change
useEffect(() => {
  setDisplayCount(20)
}, [state.filters])
```

---

## Tailwind CSS Configuration

Catalyst requires Tailwind CSS v4.0+. Create `src/styles/tailwind.css`:

```css
@import 'tailwindcss';

@theme {
  --font-sans: 'Inter', system-ui, sans-serif;
  --font-sans--font-feature-settings: 'cv11';
  
  /* Custom design tokens */
  --color-brand: var(--color-indigo-600);
  --radius-chip: 0.375rem;
}
```

**Note:** Catalyst components use Tailwind v4's CSS-first configuration with `@theme` blocks and CSS variables.

---

## Environment Variables

```bash
# .env.local

# Groq - LLM for filter generation
GROQ_API_KEY=gsk_...

# OpenAI - GPT-4 Vision for image analysis
OPENAI_API_KEY=sk-...
```

```bash
# .env.example
GROQ_API_KEY=
OPENAI_API_KEY=
```

---

## Design System

### Catalyst UI Kit

We use the **Catalyst UI Kit** from Tailwind Labs. Components are located in `src/components/catalyst/`.

#### Component Mapping

| App Component | Catalyst Component(s) | Usage |
|--------------|----------------------|-------|
| Filter chips | `BadgeButton` | Clickable filter suggestions in chat |
| Chat input | `Input`, `Textarea` | Text entry in prompt area |
| Send/Action buttons | `Button` | Send message, regenerate, add to cart |
| Chat sidebar | `Sidebar`, `SidebarBody`, `SidebarFooter` | Chat container structure |
| Filter checkboxes | `Checkbox`, `CheckboxField`, `CheckboxGroup` | Color/material multi-select |
| In-stock toggle | `Switch`, `SwitchField` | Boolean filter toggle |
| Category select | `Select` or `Listbox` | Category/subcategory dropdowns |
| Form fields | `Field`, `Label`, `Description` | Filter panel form layout |
| Text content | `Heading`, `Text` | Chat messages, headings |
| Modals | `Dialog`, `DialogTitle`, `DialogBody` | Confirmations if needed |
| Dropdowns | `Dropdown`, `DropdownButton`, `DropdownMenu` | Cart menu, settings |

#### Custom Components (Not in Catalyst)

| Component | Implementation |
|-----------|---------------|
| `Slider` | Radix UI slider with Tailwind styling |
| `Skeleton` | Tailwind shimmer animation |
| `ProductCard` | Custom card with image, title, price, cart button |
| `ProductGrid` | CSS Grid responsive layout |
| `ImagePreview` | Image thumbnail with remove button |
| `ResizeHandle` | Custom draggable divider |

#### Catalyst Color Palette

Catalyst components support these color props:

```typescript
// Available colors for Badge, Button, Checkbox, Switch
type Color = 
  | 'dark/zinc' | 'dark/white' | 'dark' | 'white' | 'zinc'
  | 'red' | 'orange' | 'amber' | 'yellow' | 'lime' 
  | 'green' | 'emerald' | 'teal' | 'cyan' | 'sky'
  | 'blue' | 'indigo' | 'violet' | 'purple' 
  | 'fuchsia' | 'pink' | 'rose'
```

**Filter Chip Colors (by type):**
- Category/Subcategory: `indigo`
- Color filters: `zinc` (default)
- Material filters: `amber`
- Style tags: `violet`
- Size: `sky`
- Price: `emerald`

### Design Tokens

```typescript
// styles/tokens.ts

export const tokens = {
  spacing: {
    sidebarMinPx: 250,
    sidebarDefaultPercent: 30,
    sidebarMaxPercent: 50,
    gridGap: 16,
    cardPadding: 16,
  },
  
  timing: {
    fast: 150,
    normal: 300,
    slow: 500,
  },
}
```

### Animation Variants

```typescript
// styles/animations.ts

export const fadeIn = {
  initial: { opacity: 0 },
  animate: { opacity: 1 },
  exit: { opacity: 0 },
  transition: { duration: 0.15 },
}

export const slideInLeft = {
  initial: { x: -20, opacity: 0 },
  animate: { x: 0, opacity: 1 },
  exit: { x: -20, opacity: 0 },
  transition: { duration: 0.2 },
}

export const chipAppear = {
  initial: { scale: 0.8, opacity: 0 },
  animate: { scale: 1, opacity: 1 },
  transition: { type: 'spring', stiffness: 500, damping: 30 },
}

export const messageAppear = {
  initial: { y: 10, opacity: 0 },
  animate: { y: 0, opacity: 1 },
  transition: { duration: 0.2 },
}

export const shimmer = {
  animate: {
    backgroundPosition: ['200% 0', '-200% 0'],
  },
  transition: {
    duration: 1.5,
    repeat: Infinity,
    ease: 'linear',
  },
}
```

---

## Implementation Order

### Phase 1: Foundation
1. `npx create-next-app@latest` with TypeScript + Tailwind v4 + App Router
2. Install Catalyst dependencies: `npm install @headlessui/react motion clsx`
3. Copy Catalyst components to `src/components/catalyst/`
4. Install additional deps: `npm install zod @radix-ui/react-slider`
5. Create project structure
6. Define types in `types/index.ts`
7. Create `products.json` with sample data (~50 items first)
8. Build `useAppState` hook

### Phase 2: Layout & Filters
1. Build Header (with static SearchBar)
2. Build FilterPanel with all filter types
3. Build ChatToggleButton (below FilterPanel)
4. Implement filter engine (AND logic)
5. Implement product ranking (match score)
6. Build ProductGrid + ProductCard
7. Add infinite scroll
8. Test traditional filtering flow with ranking

### Phase 3: Chat Interface
1. Build ChatSidebar structure
2. Build PromptInput with image upload
3. Build Message + FilterChip components
4. Build ConversationThread
5. Build RegenerateButton
6. Implement ResizeHandle
7. Test sidebar toggle

### Phase 4: AI Integration
1. Set up `/api/chat` route with Groq
2. Build prompt templates
3. Implement Zod validation schemas
4. Build LLM response validator (validate.ts)
5. Implement filter generation flow with validation
6. Set up `/api/vision` route with GPT-4
7. Implement image → description → filters flow
8. Set up `/api/regenerate` route
9. Set up `/api/similar` route for zero results
10. Test all flows with validation

### Phase 5: Polish
1. Add framer-motion animations
2. Loading states (skeletons, shimmer)
3. Error handling
4. Price question UI
5. Zero results UI
6. Cart functionality
7. Final testing

---

## Unclear Items (Need Answers)

### 1. SearchBar Behavior
The search bar in the header is static for now. Should clicking it:
- Do nothing (completely disabled)?
- Show a tooltip "Coming soon"?
- Focus the chat input?

### 2. Price Question Interaction
When assistant asks "What's your budget?", should this be:
- **Option A:** Just text - user types response
- **Option B:** Quick buttons like "$0-50", "$50-100", "$100-200", "$200+"
- **Option C:** Both - text with suggested price range buttons

### 3. Zero Results UI Location
When filters produce zero results, where should alternatives appear?
- **Option A:** As a chat message in the sidebar
- **Option B:** Inline in the ProductGrid area
- **Option C:** Both

### 4. Regenerate Behavior
When user clicks "Regenerate", should we:
- **Option A:** Replace the chips in the existing message
- **Option B:** Add a new assistant message with alternatives
- **Option C:** Show chips inline below the button

---

## Notes

- **No embeddings** - All search is LLM-based filter generation
- **No backend database** - All data is JSON files  
- **No auth** - Single user experience
- **No analytics** - Not needed for MVP
- **Desktop only** - No responsive/mobile
- **Keep it simple** - Avoid premature optimization
