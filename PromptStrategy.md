# Shopping Assistant - Prompt Strategy

## Overview

This document defines how we translate user intent into filter suggestions. The strategy balances **flexibility** (handling novel concepts) with **consistency** (reliable, grounded outputs).

**Key Insight:** We don't need to map every possible concept. We constrain the OUTPUT to valid catalog values, letting the LLM reason freely about INPUT.

---

## The Four-Layer System

```
┌─────────────────────────────────────────────────────────────────┐
│                    LAYER 1: Core Mappings                        │
│                    (~20-30 common concepts)                      │
│                                                                  │
│    "warm" → sweaters, wool       "casual" → t-shirts, jeans     │
│    "running" → cotton, casual    "formal" → silk, elegant       │
│    (NO color mappings - colors are data-driven)                 │
└───────────────────────────┬─────────────────────────────────────┘
                            │ If not found in mappings...
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│                  LAYER 2: Few-Shot Reasoning                     │
│                  (LLM generalizes from examples)                 │
│                                                                  │
│    "How to reason about temperature, aesthetics, occasions"      │
│    LLM applies learned patterns to new concepts                 │
│    LLM generates: subcategory, material, style chips            │
│    CONTEXT-AWARE: Only suggests relevant materials/styles       │
└───────────────────────────┬─────────────────────────────────────┘
                            │ Whatever LLM outputs...
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│                  LAYER 3: Zod Validation                         │
│                  (Only catalog values pass through)              │
│                                                                  │
│    ✓ "wool" exists in materials    ✗ "peasant blouse" invalid   │
│    ✓ "sweaters" exists in subcats  ✗ color chips removed        │
└───────────────────────────┬─────────────────────────────────────┘
                            │ After validation...
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│                  LAYER 4: Data-Driven Colors Only                │
│                                                                  │
│  COLORS: Fully derived from catalog (LLM colors removed)        │
│    Query: "What colors exist for sweaters + hoodies?"           │
│    Result: brown, gray, navy, cream (actual catalog data)       │
│                                                                  │
│  MATERIALS: Fully LLM-driven (NO supplementation)               │
│    LLM suggests only context-appropriate materials              │
│    "running" → cotton, polyester (NOT cashmere, silk)           │
│                                                                  │
│  STYLE TAGS: Fully LLM-driven (NO supplementation)              │
│    LLM suggests only context-appropriate styles                 │
│    "running" → casual, fitted (NOT formal, elegant)             │
└─────────────────────────────────────────────────────────────────┘
```

### Why Data-Driven Colors?

Colors are **not generated by the LLM** for several reasons:

1. **No hallucination risk** - Users only see colors that actually exist
2. **Always accurate** - Colors are derived from real product data
3. **Better UX** - If user selects "hoodies + pink" and no pink hoodies exist, we can show "none available" instead of confusing results
4. **Dynamic** - As catalog changes, color suggestions update automatically
5. **Objective** - A product IS blue or it isn't - no context interpretation needed

### Why LLM-Only for Materials?

Materials are **fully LLM-driven** (no catalog supplementation):

1. **Context-awareness** - LLM understands "running" needs athletic fabrics, not cashmere
2. **Intent preservation** - Only materials that make sense for the use case are suggested
3. **No noise** - Users don't see irrelevant options that happen to exist in the catalog
4. **Better UX** - "running outfit" shows cotton, polyester, fleece (NOT cashmere, silk, leather)

**Previous issue:** Catalog supplementation added ALL materials available for the subcategories, regardless of whether they made sense for the query. This caused "running" to suggest cashmere, leather, etc.

### Why LLM-Only for Style Tags?

Style tags are **fully LLM-driven** (no catalog supplementation):

1. **Context-awareness** - LLM understands "running" needs athletic styles, not formal/elegant
2. **Intent preservation** - Only styles that make sense for the occasion are suggested
3. **No noise** - Users don't see irrelevant style options
4. **Better UX** - "running outfit" shows casual, fitted, modern (NOT formal, elegant, vintage)

**Previous issue:** Catalog supplementation added ALL style tags available for the subcategories, regardless of whether they made sense for the query. This caused "running" to suggest formal, elegant, edgy, etc.

---

## Hierarchy Rules

The LLM must decide **what type of filters to suggest first** based on user intent:

### Rule 1: Specific Subcategory Mentioned → Use It Directly

```
User: "I want a blue sweater"

→ Subcategory is explicit: sweaters
→ Output: [subcategory: sweaters, color: blue]
→ Then suggest: materials, style tags
```

### Rule 2: Vague Concept → Subcategory First, Then Attributes

```
User: "Something warm"

→ "warm" maps to subcategory candidates
→ Output Step 1: [sweaters, coats, hoodies, fleece jackets]
→ After user selects → Output Step 2: [wool, cashmere, fleece]
```

### Rule 3: Specific Attribute Only → Use It, Skip Subcategory

```
User: "Something blue"

→ No subcategory implied
→ Output: [color: blue]
→ Optional follow-up: "What type of clothing are you looking for?"
```

### Rule 4: Truly Ambiguous → Ask Clarifying Question

```
User: "Something nice"

→ Too vague to map confidently
→ Output: "What occasion is this for? [Casual] [Work] [Date night] [Special event]"
```

---

## Layer 1: Core Concept Mappings

These are high-frequency, potentially ambiguous terms with explicit mappings.

### Temperature / Season

| Concept | Subcategories | Materials | Style Tags | Colors |
|---------|---------------|-----------|------------|--------|
| warm | sweaters, coats, hoodies, jackets, pants | wool, cashmere, fleece | cozy, winter | — |
| cool / light | t-shirts, blouses, dresses, skirts | linen, cotton | lightweight, breathable | — |
| summer | dresses, t-shirts, blouses, skirts, pants | linen, cotton | casual, lightweight | bright colors |
| winter | coats, sweaters, hoodies, jackets, pants, jeans | wool, fleece | cozy, layered | — |
| fall / autumn | sweaters, jackets, jeans, pants, dresses, skirts | wool, denim | layered, cozy | earth tones |
| spring | blouses, dresses, skirts, t-shirts, pants, jeans | cotton, linen | fresh, light | pastels |

### Formality / Occasion

| Concept | Subcategories | Materials | Style Tags |
|---------|---------------|-----------|------------|
| casual | t-shirts, jeans, hoodies, sweaters, jackets, pants, dresses, skirts, blouses | cotton, denim | relaxed, everyday, comfortable |
| professional / work | blouses, pants, skirts, dresses, jackets, coats, sweaters | wool, cotton | formal, business, classic |
| formal / dressy | dresses, blouses, pants, skirts, coats, jackets | silk, wool | elegant, sophisticated |
| date night | dresses, blouses, skirts, pants, jackets, sweaters | silk, satin, velvet | elegant, fitted, romantic |
| loungewear / comfort | hoodies, pants, sweaters, t-shirts, dresses, jeans | fleece, cotton | cozy, relaxed, soft |

### Color Families (For LLM Context Only)

**Note:** The LLM does NOT generate color chips. Colors are automatically derived from the catalog based on suggested subcategories. However, the LLM understands color concepts to better suggest appropriate subcategories and materials.

| Concept | What it means (for LLM reasoning) |
|---------|-----------------------------------|
| earth tones | Warm, natural colors - suggests outdoor/casual subcategories |
| neutrals | Classic, versatile - suggests professional/minimalist styles |
| pastels | Soft, light - suggests spring/romantic styles |
| jewel tones | Rich, deep - suggests formal/elegant styles |
| brights / bold | Vivid, attention-grabbing - suggests casual/statement pieces |
| monochrome | Black/white/gray - suggests minimalist/modern styles |

The actual color chips shown to users are derived from products in the suggested subcategories.

### Aesthetic / Vibe

| Concept | Subcategories | Materials | Style Tags | Colors |
|---------|---------------|-----------|------------|--------|
| minimalist | t-shirts, pants, blouses, dresses, coats, sweaters, jeans, skirts | cotton, linen | clean, simple, modern | neutrals |
| bohemian / boho | dresses, blouses, skirts, pants, jackets, sweaters, t-shirts | linen, cotton | flowy, relaxed, artistic | earth tones |
| preppy | blouses, pants, sweaters, skirts, jackets, dresses, coats | cotton, wool | classic, polished | navy, white, pastels |
| streetwear | hoodies, jeans, t-shirts, jackets, pants, sweaters, coats, dresses | cotton, denim | urban, casual, oversized | — |
| vintage / retro | dresses, jeans, blouses, skirts, jackets, sweaters, pants, t-shirts | denim, leather | vintage, retro, classic | — |
| edgy / punk | jackets, jeans, t-shirts, pants, coats, hoodies, dresses, skirts | leather, denim | edgy, bold | black |
| romantic | dresses, blouses, skirts, sweaters, pants | silk | feminine, delicate, flowy | pastels, florals |
| cozy | sweaters, hoodies, pants, t-shirts, jackets, dresses, jeans, skirts | fleece, wool, knit | comfortable, oversized, soft | — |

### Fit / Style

| Concept | Style Tags / Attributes |
|---------|------------------------|
| oversized | oversized, relaxed, loose |
| fitted | fitted, slim, tailored |
| flowy | flowy, loose, relaxed |
| structured | structured, tailored, sharp |
| cropped | cropped |
| high-waisted | high-waisted |

---

## Layer 2: Few-Shot Reasoning Examples

These examples teach the LLM HOW to reason about concepts not in the core mappings.

### Example 1: Temperature/Comfort Concept

```
User says: "cozy"

Think: "cozy" is about physical comfort and warmth feeling
→ Subcategories: things that are soft and warm (sweaters, hoodies, cardigans)
→ Materials: soft textures (fleece, cashmere, knit, wool)
→ Style: relaxed, oversized, comfortable
→ No specific color implied
```

### Example 2: Aesthetic/Trend Concept

```
User says: "dark academia"

Think: "dark academia" is a trending aesthetic — scholarly, intellectual, moody
→ Subcategories: blazers, sweaters, collared-shirts, plaid-skirts
→ Materials: wool, tweed, cotton
→ Style: classic, preppy, vintage
→ Colors: brown, burgundy, navy, forest-green, cream
```

### Example 3: Occasion Concept

```
User says: "beach vacation"

Think: This is occasion + climate
→ Subcategories: swimwear, shorts, sundresses, sandals, cover-ups
→ Materials: linen, cotton (breathable, light)
→ Style: casual, relaxed, lightweight
→ Colors: bright, tropical, white
```

### Example 4: Specific Attribute

```
User says: "I need something in size medium"

Think: Size is a specific attribute, not vague
→ Don't need to infer subcategory
→ Just apply size filter: medium
→ Ask follow-up: "What type of clothing are you looking for?"
```

### Example 5: Ambiguous Request

```
User says: "something nice"

Think: Too vague — "nice" could mean anything
→ Don't guess
→ Ask: "What's the occasion? [Casual everyday] [Work] [Date] [Special event]"
```

---

## Layer 2.5: Selected Chips Exclusion (Phase 2)

When the user has already selected chips, the prompt includes an exclusion list:

```
═══════════════════════════════════════════════════════════════════
ALREADY SELECTED (DO NOT SUGGEST THESE - user already has them active)
═══════════════════════════════════════════════════════════════════

- subcategory: jeans
- style_tag: casual
- material: denim

IMPORTANT: Do NOT include any of the above values in your "chips" response.
The user has already selected these filters. Focus on suggesting NEW options
based on their message.
```

This ensures:
- LLM won't suggest duplicates of what user already selected
- User sees fresh suggestions based on their new query
- Selected chips persist and appear first in UI

---

## Layer 3: Validation Rules

All LLM outputs are validated against catalog facets using Zod schemas.

### What Gets Validated

| Field | Validation |
|-------|------------|
| `subcategory` | Must exist in `catalog.subcategories` |
| `materials` | Each material must exist in `catalog.materials` |
| `styleTags` | Each tag must exist in `catalog.styleTags` |
| `sizes` | Each size must exist in `catalog.sizes` |

**Note:** Color chips are removed during validation (they shouldn't be generated by LLM).

### What Happens to Invalid Values

1. **Invalid chip is silently removed** — user never sees it
2. **Color chips are removed** — colors are added in Layer 4 instead
3. **Valid chips from same response are kept** — partial success
4. **Error is logged for debugging** — we can improve mappings

## Layer 4: Data-Driven Colors (Only)

After validation, the system adds data-driven color chips only:

### Colors (Fully Data-Driven)
1. Remove any LLM-generated color chips (colors should not come from LLM)
2. Extract subcategory values from LLM chips
3. Query catalog: "What colors exist for these subcategories?"
4. Create color chips for each unique color found
5. Add all color chips to the response

**Why colors are data-driven:**
- Colors are objective - a product IS blue or it isn't
- No context interpretation needed
- Prevents hallucination of colors that don't exist

### Materials (Fully LLM-Driven)
Materials are generated entirely by the LLM with NO catalog supplementation.

**Why LLM-only for materials:**
- Materials are context-dependent (cashmere is valid for "cozy" but NOT for "running")
- LLM understands user intent and only suggests relevant materials
- Supplementation with catalog data added irrelevant options (e.g., cashmere for athletic wear)

**Example:**
```
User: "running outfit"
LLM suggests: [cotton, polyester, fleece]  ← Only athletic-appropriate fabrics
Catalog would have: [cotton, polyester, fleece, cashmere, silk, leather, linen, denim, wool]
                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                                                 These are NOT suggested because they don't
                                                 make sense for running
```

### Style Tags (Fully LLM-Driven)
Style tags are generated entirely by the LLM with NO catalog supplementation.

**Why LLM-only for style tags:**
- Style tags are context-dependent (formal makes sense for "work" but NOT for "running")
- LLM understands user intent and only suggests relevant styles
- Supplementation with catalog data added irrelevant options (e.g., elegant for athletic wear)

**Example:**
```
User: "running outfit"
LLM suggests: [casual, fitted, modern, relaxed]  ← Only athletic-appropriate styles
Catalog would have: [casual, fitted, modern, relaxed, formal, elegant, vintage, romantic, edgy]
                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                                                       These are NOT suggested because they don't
                                                       make sense for running
```

### Price Extraction (LLM-Driven, Explicit Amounts Only)

**Price is NOT a filter chip** - it's controlled via a slider component. The LLM extracts price values from user queries and returns them as `minPrice` and `maxPrice` fields.

**CRITICAL: Only extract from EXPLICIT dollar amounts:**
- **Max price patterns**: "budget is $X", "under $X", "up to $X" → `maxPrice: X`
- **Min price patterns**: "at least $X", "minimum $X", "over $X" → `minPrice: X`
- **Range patterns**: "between $X and $Y" → `minPrice: X, maxPrice: Y`
- **No price mentioned**: `minPrice: null, maxPrice: null` + include `priceQuestion`

**DO NOT infer price from subjective terms:**
- "luxury", "premium", "high-end" → `minPrice: null, maxPrice: null`
- "budget", "cheap", "affordable" → `minPrice: null, maxPrice: null`
- "mid-range", "reasonable" → `minPrice: null, maxPrice: null`

**Example:** "I want luxury sweaters" → NO price extraction (luxury is subjective)
**Example:** "Premium coats at least $200" → `minPrice: 200` (explicit $200 mentioned)

The extracted prices are applied directly to product filtering and update the price slider range.

### Summary: What's LLM-Driven vs Data-Driven

| Chip Type | Source | Rationale |
|-----------|--------|-----------|
| Subcategories | LLM | Context-dependent (what types of clothing fit the query) |
| Materials | LLM | Context-dependent (what fabrics are appropriate for the use case) |
| Style Tags | LLM | Context-dependent (what styles match the aesthetic/occasion) |
| Colors | Data | Objective (what colors actually exist for the subcategories) |
| Sizes | LLM | Context-dependent (user might specify size preferences) |
| Price | LLM | Extracted from user queries, controls slider (not a chip) |

### Example: Full Processing Pipeline

```
User Input: "I want a cozy sweater"

LLM Output:
{
  "chips": [
    { "type": "subcategory", "filterValue": "sweaters" },
    { "type": "material", "filterValue": "wool" },
    { "type": "material", "filterValue": "cashmere" },
    { "type": "color", "filterValue": "mauve" },              // ✗ LLM shouldn't generate colors
    { "type": "style_tag", "filterValue": "cozy" }
  ]
}

After Layer 3 (Validation):
- subcategory: sweaters ✓
- material: wool ✓
- material: cashmere ✓
- color: mauve ✗ removed (colors are data-driven)
- style_tag: cozy ✓

After Layer 4 (Data-Driven Facets):
{
  "chips": [
    // Subcategories
    { "type": "subcategory", "filterValue": "sweaters" },
    
    // Materials: LLM suggestions first, then catalog supplements
    { "type": "material", "filterValue": "wool" },           // LLM
    { "type": "material", "filterValue": "cashmere" },       // LLM
    { "type": "material", "filterValue": "cotton" },         // Catalog supplement
    { "type": "material", "filterValue": "fleece" },         // Catalog supplement
    
    // Colors: fully derived from catalog
    { "type": "color", "filterValue": "brown" },             // From sweaters in catalog
    { "type": "color", "filterValue": "cream" },
    { "type": "color", "filterValue": "gray" },
    { "type": "color", "filterValue": "navy" },
    
    // Style tags: LLM suggestions first, then catalog supplements
    { "type": "style_tag", "filterValue": "cozy" },          // LLM
    { "type": "style_tag", "filterValue": "casual" },        // Catalog supplement
    { "type": "style_tag", "filterValue": "classic" },       // Catalog supplement
    { "type": "style_tag", "filterValue": "oversized" }      // Catalog supplement
  ]
}
```

---

## Prompt Template Structure

The final prompt sent to Groq combines all three layers:

```typescript
function buildFilterPrompt(facets: CatalogFacets, currentFilters: FilterState): string {
  return `You are a shopping assistant for a clothing store.

Your job: Understand what the user wants and suggest filter chips they can click.

═══════════════════════════════════════════════════════════════════
AVAILABLE FILTERS (ONLY use these exact values)
═══════════════════════════════════════════════════════════════════

Subcategories: ${facets.subcategoriesByCategory.apparel.join(', ')}
Colors: ${facets.colors.join(', ')}
Materials: ${facets.materials.join(', ')}
Style Tags: ${facets.styleTags.join(', ')}
Sizes: ${facets.sizes.join(', ')}
Price Range: $${facets.priceRange.min} - $${facets.priceRange.max}

═══════════════════════════════════════════════════════════════════
HIERARCHY RULES
═══════════════════════════════════════════════════════════════════

1. Specific subcategory mentioned → use it directly, then suggest attributes
2. Vague concept (warm, casual, professional) → suggest subcategory FIRST
3. Specific attribute only (color, size) → use it, ask about subcategory
4. Truly ambiguous → ask clarifying question, don't guess

═══════════════════════════════════════════════════════════════════
CORE CONCEPT MAPPINGS (use these for common terms)
═══════════════════════════════════════════════════════════════════

Temperature:
- "warm" → subcategories: sweaters, coats, hoodies | materials: wool, fleece
- "cool/light" → subcategories: t-shirts, shorts | materials: linen, cotton

Formality:
- "casual" → subcategories: t-shirts, jeans, hoodies | style: relaxed
- "professional" → subcategories: blazers, dress-shirts | style: formal, business
- "formal" → subcategories: dresses, suits | style: elegant

Colors:
- "earth tones" → colors: brown, beige, olive, tan, rust
- "neutrals" → colors: black, white, gray, beige, navy
- "pastels" → colors: pink, lavender, mint, baby-blue

═══════════════════════════════════════════════════════════════════
REASONING EXAMPLES (apply similar logic to new concepts)
═══════════════════════════════════════════════════════════════════

Example: "cozy"
→ Subcategories: sweaters, hoodies (soft, warm items)
→ Materials: fleece, cashmere, knit
→ Style: relaxed, oversized

Example: "beach vacation"  
→ Subcategories: swimwear, shorts, sundresses
→ Materials: linen, cotton (breathable)
→ Style: casual, lightweight

Example: "something nice" (too vague)
→ Ask: "What's the occasion?"

═══════════════════════════════════════════════════════════════════
CURRENT FILTERS APPLIED
═══════════════════════════════════════════════════════════════════

${JSON.stringify(currentFilters, null, 2)}

═══════════════════════════════════════════════════════════════════
RESPONSE FORMAT (JSON only)
═══════════════════════════════════════════════════════════════════

{
  "message": "Brief, helpful response",
  "chips": [
    { "type": "subcategory", "label": "Sweaters", "filterKey": "subcategory", "filterValue": "sweaters" },
    { "type": "color", "label": "Blue", "filterKey": "colors", "filterValue": "blue" }
  ],
  "minPrice": null,
  "maxPrice": 200,
  "priceQuestion": null
}

REQUIRED FIELDS:
- "message": string (brief, friendly response)
- "chips": array of filter chips
- "minPrice": number or null (extracted minimum price)
- "maxPrice": number or null (extracted maximum price)
- "priceQuestion": string or null (ask about budget if not mentioned)

PRICE LOGIC:
- If user mentions budget/max → set maxPrice, leave priceQuestion null
- If user mentions minimum → set minPrice, leave priceQuestion null
- If user mentions range → set both minPrice and maxPrice
- If NO price mentioned → set both to null, include priceQuestion

Respond with valid JSON only. No markdown, no explanation outside JSON.`
}
```

---

## Edge Case Handling

### Case 1: Novel Aesthetic (e.g., "cottagecore", "quiet luxury")

**Flow:**
1. Not in core mappings
2. LLM uses reasoning examples to infer: "cottagecore = rural, romantic, natural"
3. LLM outputs: subcategories (dresses, blouses), materials (linen, cotton), style (romantic, flowy), colors (cream, pastels)
4. Zod validates all values exist
5. User sees valid chips

### Case 2: LLM Suggests Non-Existent Value

**Flow:**
1. LLM outputs `color: "sage green"`
2. Catalog only has: green, olive, mint
3. Zod validation fails for that chip
4. Chip is silently dropped
5. User sees other valid chips
6. (Optional) Log error to improve catalog or mappings

### Case 3: Completely Unclear Request

**Flow:**
1. User: "asdfghjkl" or "show me stuff"
2. LLM can't match to any concept
3. LLM follows Rule 4: ask clarifying question
4. Response: "What are you looking for? [Tops] [Bottoms] [Dresses] [Outerwear]"

### Case 4: Conflicting Filters

**Flow:**
1. User: "I want a warm linen shirt"
2. Conflict: linen is cool/breathable, "warm" implies wool/fleece
3. LLM should surface this: "Linen is typically a cool, breathable fabric. Were you looking for a warm shirt in a different material like flannel or wool, or a linen shirt for warmer weather?"

---

## Maintenance

### Adding New Core Mappings

When a concept becomes common (e.g., "quiet luxury" trends), add to core mappings:

```typescript
"quiet luxury": {
  subcategories: ["cashmere-sweaters", "tailored-pants", "silk-blouses"],
  materials: ["cashmere", "silk", "wool"],
  styleTags: ["minimalist", "elegant", "quality"],
  colors: ["neutrals", "cream", "camel", "navy"]
}
```

### Expanding the Catalog

When adding new products with new attributes:
1. Update `products.json`
2. Facets are auto-generated from catalog scan
3. Prompt automatically includes new values
4. Consider adding relevant core mappings if needed

---

## Related Documents

- **Architecture.md** — Type definitions, Zod schemas, API routes
- **APIs.md** — Groq/OpenAI integration details
- **UserInputFlow.md** — End-to-end flow from user input to product grid

